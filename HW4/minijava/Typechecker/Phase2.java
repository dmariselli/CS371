/* This file was generated by the Amherst version of SableCC */

/*  TODO: Things we do not understand:
    BINOP for mem
    modify MEM's for what is supposed to be address location
    check basetype...
    @TODO extrapolate the whole Access.exp.......(FP).......to helper method
*/

// How to properly initialize and use Accesses.
// How to handle APrimary2ArrayRef and ANameArrayRef
package minijava.Typechecker;

import minijava.Translate.*;
import minijava.node.*;
import minijava.Type.*;
import minijava.Frame.*;
import minijava.Temp.*;
import minijava.Tree.*;

import java.util.List;
import java.util.ArrayList;

public class Phase2
{
    private Typechecker typechecker;

    Phase2(Typechecker typechecker) {
        this.typechecker = typechecker;
        typechecker.initializeMethodLabels();
    }

    void process(Node n) {
    	 throw new RuntimeException(this.getClass() + ": no process method available for "
	     + n.getClass());
    }

    ///////////////////////////////////////////////////////////////
    void process(Start n) {
         process(n.getPProgram());
    }

    ///////////////////////////////////////////////////////////////
    void process(PProgram n) {
        if (n instanceof AProgram) process((AProgram)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AProgram n) {
        n.getPublic();				// yields TPublic
        n.getClasstok();				// yields TClasstok
        n.getId();				// yields TId
        n.getLbrace();				// yields TLbrace
        for (PMaindecl p : n.getMaindecl())
            process(p);				// process(PMaindecl)
        n.getRbrace();				// yields TRbrace
    }

    ///////////////////////////////////////////////////////////////
    void process(PMaindecl n) {
        if (n instanceof AVarMaindecl) process((AVarMaindecl)n);
	else if (n instanceof AMethodMaindecl) process((AMethodMaindecl)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AVarMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi
        Var var = typechecker.createClassVar(n.getId().getText(), process(n.getType()));
        Label label = typechecker.getMachine().makeLabel("v_"  + n.getId().getText());
        var.setLabel(label);
//        Access access = typechecker.getCurrentMethod().getFrame().allocLocal();
//        var.setAccess(access);
    }

    ///////////////////////////////////////////////////////////////
    void process(AMethodMaindecl n) {
        typechecker.nextMethod();
        Method method = typechecker.getCurrentMethod();
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        typechecker.localST.increaseScope();
        method.makeFrame(typechecker.getMachine());
        process(n.getParamlist());			// process(PParamlist)
        n.getRparen();				// yields TRparen
        n.getLbrace();				// yields TLbrace
        Label l1 = new Label();
        method.setExitLabel(l1);
        List<PStmt> stmts = n.getStmt();
        if (!stmts.isEmpty()) {
            method.startTree(process(stmts.get(0)));
            for (int i = 1; i < stmts.size(); i++) {
                method.addToTree(process(stmts.get(i)));
            }
        } else {
            method.startTree(typechecker.noop());
        }
        Stm exitLabel = new LABEL(l1);
        method.addToTree(exitLabel);
        if (!method.getReturnType().equals(Type.voidType)) {
            MOVE move = new MOVE(new TEMP(method.getFrame().RV()), method.getHidden().getAccess().exp(new TEMP(method.getFrame().FP())));
            method.addToTree(move);
        }
        //TODO Add these tree fragments to method
//        TODO: Determine what is being returned in the TEMP with reg to it. See if you need to add the FP or SP to get the right thing.
//        And put it in the MOVE. Also we need to figure out how to initialize the Access in Hidden Variable.
        n.getRbrace();				// yields TRbrace
        typechecker.localST.decreaseScope();
    }

    ///////////////////////////////////////////////////////////////
    Stm process(PParamlist n) {
        if (n instanceof AListParamlist) return process((AListParamlist)n);
        else if (n instanceof AEmptyParamlist) return process((AEmptyParamlist)n);
        else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PParamlist)");
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AListParamlist n) {
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        typechecker.localST.declareLocal(n.getId().getText(), process(n.getType()));
        Access access = typechecker.getCurrentMethod().getFrame().allocLocal();
        typechecker.localST.lookup(n.getId().getText()).setAccess(access);
        for (PParam p : n.getParam())
            process(p);				// process(PParam)
        return typechecker.noop();
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AEmptyParamlist n) {
        return typechecker.noop();
    }

    ///////////////////////////////////////////////////////////////
    void process(PParam n) {
        if (n instanceof AParam) process((AParam)n);
	    else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PParam)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AParam n) {
        n.getComma();				// yields TComma
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        typechecker.localST.declareLocal(n.getId().getText(), process(n.getType()));
    }

    ///////////////////////////////////////////////////////////////
    void process(PPrivacy n) {
        if (n instanceof APublicPrivacy) process((APublicPrivacy)n);
	else if (n instanceof ABlankPrivacy) process((ABlankPrivacy)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PPrivacy)");
    }

    ///////////////////////////////////////////////////////////////
    void process(APublicPrivacy n) {
        n.getPublic();				// yields TPublic
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlankPrivacy n) {
    }

    ///////////////////////////////////////////////////////////////
    Type process(PType n) {
        if (n instanceof AType) return process((AType)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PType)");
    }

    ///////////////////////////////////////////////////////////////
    Type process(AType n) {
        Type type = typechecker.getType(n.getId());
        for (PEmptydim p : n.getEmptydim())
            type = typechecker.makeArrayType(type, n.getId());
        System.out.println("Type is "+type);
        return type;
    }

    ///////////////////////////////////////////////////////////////
    Stm process(PStmt n) {
        if (n instanceof AWhileStmt) return process((AWhileStmt)n);
	else if (n instanceof ADeclStmt) return process((ADeclStmt)n);
	else if (n instanceof ABlockStmt) return process((ABlockStmt)n);
	else if (n instanceof AIfStmt) return process((AIfStmt)n);
	else if (n instanceof AExprStmt) return process((AExprStmt)n);
	else if (n instanceof AReturnStmt) return process((AReturnStmt)n);
	else if (n instanceof APrintStmt) return process((APrintStmt)n);
	else if (n instanceof AEmptyStmt) return process((AEmptyStmt)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PStmt)");
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AWhileStmt n) {
        n.getWhile();				// yields TWhile
        n.getLparen();				// yields TLparen
        ExprType exprType = process(n.getExpr());
        if (!exprType.getType().equals(Type.booleanType))			// process(PExpr)
            throw new TypecheckerException(n.getLparen(), "Incompatible type");
        n.getRparen();				// yields TRparen
        typechecker.localST.increaseScope();
        Label l1 = new Label();
        Label lt = new Label();
        Label lf = new Label();
        Stm s1 = new LABEL(l1);
        Stm s2 = exprType.getExpr().unCx(lt, lf);
        Stm s3 = new LABEL(lt);
        Stm s4 = process(n.getStmt());			// process(PStmt)
        Stm s5 = new JUMP(l1);
        Stm s6 = new LABEL(lf);
        typechecker.localST.decreaseScope();
        return typechecker.seq(s1, s2, s3, s4, s5, s6);
    }

    ///////////////////////////////////////////////////////////////
    Stm process(ADeclStmt n) {
        //TODO: CHECK THIS.
        Type type = process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi
        boolean declared = typechecker.localST.declareLocal(n.getId().getText(), type);
        if (!declared) {
            throw new TypecheckerException(n.getId(), "A variable of the same name has already been declared.");
        }
        Access access = typechecker.getCurrentMethod().getFrame().allocLocal();
        typechecker.localST.lookup(n.getId().getText()).setAccess(access);
        return new ESTM((access.exp(new TEMP(typechecker.getCurrentMethod().getFrame().FP()))));
    }

    ///////////////////////////////////////////////////////////////
    Stm process(ABlockStmt n) {
        n.getLbrace();				// yields TLbrace
        Stm tree = typechecker.noop();
        if (n.getStmt().size()>0) {
            tree = process(n.getStmt().get(0));
        }
        for (int i = 1; i<n.getStmt().size(); i++) {
            tree = new SEQ(tree, process(n.getStmt().get(i)));				// process(PStmt)
        }
        n.getRbrace();				// yields TRbrace
        return tree;
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AIfStmt n) {
        n.getIf();				// yields TIf
        n.getLparen();				// yields TLparen
        ExprType exprType = process(n.getExpr());
        if (!exprType.getType().equals(Type.booleanType))			// process(PExpr)
            throw new TypecheckerException(n.getLparen(), "Incompatible type");
        n.getRparen();				// yields TRparen
        typechecker.localST.increaseScope();
        Label lt = new Label();
        Label lf = new Label();
        Label lout = new Label();
        Stm s1 = exprType.getExpr().unCx(lt, lf);
        Stm s2 = new LABEL(lt);
        Stm s3 = process(n.getThenclause());			// process(PStmt)
        Stm s4 = new JUMP(lout);
        typechecker.localST.decreaseScope();
        n.getElse();				// yields TElse
        typechecker.localST.increaseScope();
        Stm s5 = new LABEL(lf);
        Stm s6 = process(n.getElseclause());			// process(PStmt)
        Stm s7 = new LABEL(lout);
        typechecker.localST.decreaseScope();
        return typechecker.seq(s1, s2, s3, s4, s5, s6, s7);
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AExprStmt n) {
        n.getSemi();				// yields TSemi
        return new ESTM(process(n.getExpr()).getExpr().unEx());			// process(PExpr)
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AReturnStmt n) {
        n.getReturn();				// yields TReturn
        n.getSemi();				// yields TSemi
        Method method = typechecker.getCurrentMethod();
        Type returnType = method.getReturnType();
        if (returnType.equals(Type.voidType)){
            if (n.getExpr() != null) {
                throw new TypecheckerException(n.getReturn(), "Void method cannot return a value");
            }
            return new JUMP(method.getExitLabel());
        } else {
            if (n.getExpr()==null){
                throw new TypecheckerException(n.getReturn(), "Non-void method has to return a value");
            }
            ExprType exprType = process(n.getExpr());		// process(PExpr)
            if (!exprType.getType().canAssignTo(returnType)) {
                throw new TypecheckerException(n.getReturn(), "Return type is not valid");
            }
            method.getHidden().setAccess(typechecker.getCurrentMethod().getFrame().allocLocal());
            MOVE move = new MOVE(method.getHidden().getAccess().exp(new TEMP(method.getFrame().FP())), exprType.getExpr().unEx());
            JUMP jump = new JUMP(method.getExitLabel());
            SEQ seq = new SEQ(move, jump);
            return seq;
        }
    }

    ///////////////////////////////////////////////////////////////
    Stm process(APrintStmt n) {
        n.getPrint();				// yields TPrint
        n.getLparen();				// yields TLparen
        ExprType exprType = process(n.getExpr());
        if (exprType.getType().equals(Type.voidType)) {
            throw new TypecheckerException(n.getLparen(), "type not allowed here");
        }
        n.getRparen();				// yields TRparen
        n.getSemi();				// yields TSemi
        Exp mem = (exprType.getExpr().unEx());
        return new ESTM(new CALL(new NAME(typechecker.getBuiltins().printString), new ExpList(mem)));
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AEmptyStmt n) {
        n.getSemi();				// yields TSemi
        return typechecker.noop();
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr n) {
        if (n instanceof AAssignExpr) return process((AAssignExpr)n);
	else if (n instanceof AExprExpr) return process((AExprExpr)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AAssignExpr n) {
        ExprType lhs = process(n.getLhs());			// process(PLhs)
        ExprType rhs = process(n.getExpr());			// process(PExpr)
        if (!(rhs.getType().canAssignTo(lhs.getType()))){
            throw new TypecheckerException(n.getAssign(), "Incompatible types.");
        }
        return new ExprType(new Ex(new ESEQ(new MOVE(lhs.getExpr().unEx(), rhs.getExpr().unEx()), new CONST(0))), lhs.getType());

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr n) {
        return process(n.getExpr10());			// process(PExpr10)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr10 n) {
        if (n instanceof AOrExpr10) return process((AOrExpr10)n);
	else if (n instanceof AExprExpr10) return process((AExprExpr10)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr10)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AOrExpr10 n) {
        ExprType exprTypeLHS = process(n.getLeft());	// process(PExpr10)
        n.getOr();				// yields TOr
        ExprType exprTypeRHS = process(n.getRight());			// process(PExpr20)
        if ((!exprTypeLHS.getType().equals(Type.booleanType)) || (!exprTypeRHS.getType().equals(Type.booleanType))){
            throw new TypecheckerException(n.getOr(), "Incompatible types");
        }
        Exp or = new BINOP("OR", exprTypeLHS.getExpr().unEx(), exprTypeRHS.getExpr().unEx());
        return new ExprType(new Ex(or), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr10 n) {
        return process(n.getExpr20());			// process(PExpr20)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr20 n) {
        if (n instanceof AAndExpr20) return process((AAndExpr20)n);
	else if (n instanceof AExprExpr20) return process((AExprExpr20)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr20)");

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AAndExpr20 n) {
        ExprType exprTypeLHS = process(n.getLeft());			// process(PExpr20)
        n.getAnd();				// yields TAnd
        ExprType exprTypeRHS = process(n.getRight());			// process(PExpr30)
        if ((!exprTypeLHS.getType().equals(Type.booleanType)) || (!exprTypeRHS.getType().equals(Type.booleanType))){
            throw new TypecheckerException(n.getAnd(), "Incompatible types");
        }
        Exp and = new BINOP("AND", exprTypeLHS.getExpr().unEx(), exprTypeRHS.getExpr().unEx());
        return new ExprType(new Ex(and), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr20 n) {
        return process(n.getExpr30());			// process(PExpr30)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr30 n) {
        if (n instanceof AEqExpr30) return process((AEqExpr30)n);
	else if (n instanceof ANeExpr30) return process((ANeExpr30)n);
	else if (n instanceof AExprExpr30) return process((AExprExpr30)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr30)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AEqExpr30 n) {
        ExprType exprTypeLHS = process(n.getLeft());			// process(PExpr30)
        n.getEq();				// yields TEq
        ExprType exprTypeRHS = process(n.getRight());			// process(PExpr40)
        if ((!exprTypeLHS.getType().canAssignTo(exprTypeRHS.getType())) && (!exprTypeRHS.getType().canAssignTo(exprTypeLHS.getType()))){
            throw new TypecheckerException(n.getEq(), "Incompatible types");
        }
        //@TODO check 11/17 super sketchy cxrels
        Expr cxrel = new CxRel(n.getEq(), exprTypeLHS.getExpr(), exprTypeRHS.getExpr());
        return new ExprType(cxrel, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANeExpr30 n) {
        ExprType exprTypeLHS = process(n.getLeft());			// process(PExpr30)
        n.getNe();				// yields TNe
        ExprType exprTypeRHS = process(n.getRight());            // process(PExpr40)
        if ((!exprTypeLHS.getType().canAssignTo(exprTypeRHS.getType())) && (!exprTypeRHS.getType().canAssignTo(exprTypeLHS.getType()))){
            throw new TypecheckerException(n.getNe(), "Incompatible types");
        }
        //@TODO check 11/17 super sketchy cxrels
        Expr cxrel = new CxRel(n.getNe(), exprTypeLHS.getExpr(), exprTypeRHS.getExpr());
        return new ExprType(cxrel, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr30 n) {
        return process(n.getExpr40());			// process(PExpr40)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr40 n) {
        if (n instanceof ALtExpr40) return process((ALtExpr40)n);
	else if (n instanceof ALeExpr40) return process((ALeExpr40)n);
	else if (n instanceof AGeExpr40) return process((AGeExpr40)n);
	else if (n instanceof AGtExpr40) return process((AGtExpr40)n);
	else if (n instanceof AExprExpr40) return process((AExprExpr40)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr40)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALtExpr40 n) {
        ExprType exprTypeLHS = process(n.getLeft());			// process(PExpr40)
        n.getLt();				// yields TLt
        ExprType exprTypeRHS = process(n.getRight());            // process(PExpr50)
        if ((!exprTypeLHS.getType().equals(Type.intType)) || (!exprTypeRHS.getType().equals(Type.intType))){
            throw new TypecheckerException(n.getLt(), "Incompatible types");
        }
        //@TODO check 11/17 super sketchy cxrels
        Expr cxrel = new CxRel(n.getLt(), exprTypeLHS.getExpr(), exprTypeRHS.getExpr());
        return new ExprType(cxrel, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALeExpr40 n) {
        ExprType exprTypeLHS = process(n.getLeft());			// process(PExpr40)
        n.getLe();				// yields TLe
        ExprType exprTypeRHS = process(n.getRight());            // process(PExpr50)
        if ((!exprTypeLHS.getType().equals(Type.intType)) || (!exprTypeRHS.getType().equals(Type.intType))){
            throw new TypecheckerException(n.getLe(), "Incompatible types");
        }
        //@TODO check 11/17 super sketchy cxrels
        Expr cxrel = new CxRel(n.getLe(), exprTypeLHS.getExpr(), exprTypeRHS.getExpr());
        return new ExprType(cxrel, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AGeExpr40 n) {
        ExprType exprTypeLHS = process(n.getLeft());			// process(PExpr40)
        n.getGe();				// yields TGe
        ExprType exprTypeRHS = process(n.getRight());            // process(PExpr50)
        if ((!exprTypeLHS.getType().equals(Type.intType)) || (!exprTypeRHS.getType().equals(Type.intType))){
            throw new TypecheckerException(n.getGe(), "Incompatible types");
        }
        //@TODO check 11/17 super sketchy cxrels
        Expr cxrel = new CxRel(n.getGe(), exprTypeLHS.getExpr(), exprTypeRHS.getExpr());
        return new ExprType(cxrel, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AGtExpr40 n) {
        ExprType exprTypeLHS = process(n.getLeft());			// process(PExpr40)
        n.getGt();				// yields TGt
        ExprType exprTypeRHS = process(n.getRight());            // process(PExpr50)
        if ((!exprTypeLHS.getType().equals(Type.intType)) || (!exprTypeRHS.getType().equals(Type.intType))){
            throw new TypecheckerException(n.getGt(), "Incompatible types");
        }
        //@TODO check 11/17 super sketchy cxrels
        Expr cxrel = new CxRel(n.getGt(), exprTypeLHS.getExpr(), exprTypeRHS.getExpr());
        return new ExprType(cxrel, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr40 n) {
        return process(n.getExpr50());			// process(PExpr50)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr50 n) {
        if (n instanceof APlusExpr50) return process((APlusExpr50)n);
	else if (n instanceof AMinusExpr50) return process((AMinusExpr50)n);
	else if (n instanceof ATermExpr50) return process((ATermExpr50)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr50)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APlusExpr50 n) {
        ExprType exprTypeLHS = process(n.getLeft());            	// process(PExpr50)
        n.getPlus();				// yields TPlus
        ExprType exprTypeRHS = process(n.getRight());			// process(PTerm)
        Type type = exprTypeLHS.getType();
        if (exprTypeLHS.getType().equals(Type.stringType)){
            if (exprTypeRHS.getType().equals(Type.voidType)){
                throw new TypecheckerException(n.getPlus(), "Incompatible types");
            }
        }
        else if (exprTypeRHS.getType().equals(Type.stringType)){
            if (exprTypeLHS.getType().equals(Type.voidType)){
                throw new TypecheckerException(n.getPlus(), "Incompatible types");
            }
        }
        else if (exprTypeLHS.getType().equals(Type.intType)){
            if (!(exprTypeRHS.getType().equals(Type.intType))){
                throw new TypecheckerException(n.getPlus(), "Incompatible types");
            }
        }
        Exp lhsExp = exprTypeLHS.getExpr().unEx();
        Exp rhsExp = exprTypeRHS.getExpr().unEx();
        if (!exprTypeLHS.getType().equals(exprTypeRHS.getType())) {
            type = Type.stringType;
            if (exprTypeLHS.getType().equals(Type.intType)) {
                lhsExp = new CALL(new NAME(typechecker.getBuiltins().intToString),
                        new ExpList(exprTypeLHS.getExpr().unEx()));
            } else if (exprTypeRHS.getType().equals(Type.intType)) {
                rhsExp = new CALL(new NAME(typechecker.getBuiltins().intToString),
                        new ExpList(exprTypeRHS.getExpr().unEx()));
            }
        }
        //@TODO etch a sketch check this
        if (type.equals(Type.stringType))
            return new ExprType(new Ex((new CALL(new NAME(typechecker.getBuiltins().stringConcatenate),
                    new ExpList (lhsExp, rhsExp)))), type);
        else
            return new ExprType(new Ex(new BINOP("PLUS", lhsExp, rhsExp)), type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AMinusExpr50 n) {
        ExprType exprTypeLHS = process(n.getLeft());			// process(PExpr50)
        n.getMinus();				// yields TMinus
        ExprType exprTypeRHS = process(n.getRight());            // process(PTerm)
        if ((!exprTypeLHS.getType().equals(Type.intType)) || (!exprTypeRHS.getType().equals(Type.intType)))
        {
            throw new TypecheckerException(n.getMinus(), "Incompatible types");
        }
        Exp minus = new BINOP("MINUS", exprTypeLHS.getExpr().unEx(), exprTypeRHS.getExpr().unEx());
        return new ExprType(new Ex(minus), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATermExpr50 n) {
        return process(n.getTerm());			// process(PTerm)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PTerm n) {
        if (n instanceof ATimesTerm) return process((ATimesTerm)n);
	else if (n instanceof ADivTerm) return process((ADivTerm)n);
	else if (n instanceof AModTerm) return process((AModTerm)n);
	else if (n instanceof AFactorTerm) return process((AFactorTerm)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PTerm)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATimesTerm n) {
        ExprType exprTypeLHS = process(n.getLeft());            // process(PTerm)
        n.getTimes();				// yields TTimes
        ExprType exprTypeRHS = process(n.getRight());			// process(PFactor)
        if ((!exprTypeLHS.getType().equals(Type.intType)) || (!exprTypeRHS.getType().equals(Type.intType)))
        {
            throw new TypecheckerException(n.getTimes(), "Incompatible types");
        }
        Exp mult = new BINOP("MUL", exprTypeLHS.getExpr().unEx(), exprTypeRHS.getExpr().unEx());
        return new ExprType(new Ex(mult), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ADivTerm n) {
        ExprType ExprTypeLHS = process(n.getLeft());			// process(PTerm)
        n.getDiv();				// yields TDiv
        ExprType ExprTypeRHS = process(n.getRight());			// process(PFactor)
        if ((!ExprTypeLHS.getType().equals(Type.intType)) || (!ExprTypeRHS.getType().equals(Type.intType)))
        {
            throw new TypecheckerException(n.getDiv(), "Incompatible types");
        }
        //@TODO check
        return new ExprType(new Ex(new BINOP("DIV", ExprTypeLHS.getExpr().unEx(), ExprTypeRHS.getExpr().unEx())), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AModTerm n) {
        ExprType ExprTypeLHS = process(n.getLeft());			// process(PTerm)
        n.getMod();				// yields TMod
        ExprType ExprTypeRHS = process(n.getRight());			// process(PFactor)
        if ((!ExprTypeLHS.getType().equals(Type.intType)) || (!ExprTypeRHS.getType().equals(Type.intType)))
        {
            throw new TypecheckerException(n.getMod(), "Incompatible types");
        }
        return new ExprType(new Ex(new BINOP("MOD", ExprTypeLHS.getExpr().unEx(), ExprTypeRHS.getExpr().unEx())), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFactorTerm n) {
        return process(n.getFactor());			// process(PFactor)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PFactor n) {
        if (n instanceof APrimaryFactor) return process((APrimaryFactor)n);
	else if (n instanceof AIdFactor) return process((AIdFactor)n);
	else if (n instanceof ALengthFactor) return process((ALengthFactor)n);
	else if (n instanceof ALength2Factor) return process((ALength2Factor)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PFactor)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryFactor n) {
        return process(n.getPrimary());			// process(PPrimary)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdFactor n) {
        n.getId();				// yields TId
        Var var = typechecker.localST.lookup(n.getId().getText());
        if (var==null){
            var = typechecker.globalST.get(n.getId().getText());
            if (var==null){
                throw new TypecheckerException(n.getId(), "Variable not declared");
            }
        }
        //@TODO MEM
        return new ExprType(new Ex((var.getAccess().exp(new
                TEMP(typechecker.getCurrentMethod().getFrame().FP())))), var.getType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALengthFactor n) {
        n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        Var var = typechecker.localST.lookup(n.getId().getText());
        if (!(var.getType() instanceof ArrayType)) {
            throw new TypecheckerException(n.getId(), "Is not an array");
        }
        //@TODO MEMORY LOOKUP INDEX -1!
        Exp index = new BINOP ("MUL", new CONST(typechecker.getMachine().wordSize()), new CONST(-1));
        Exp address = new BINOP("PLUS", index, var.getAccess().exp(new TEMP(typechecker.getCurrentMethod().getFrame().FP())));
        return new ExprType(new Ex(new MEM(address)), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALength2Factor n) {
        n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        n.getLparen();				// yields TLparen
        n.getRparen();				// yields TRparen
        Var var = typechecker.localST.lookup(n.getId().getText());
        if (!((var.getType().equals(Type.stringType)))) {
            throw new TypecheckerException(n.getId(), "Is not a String");
        }
        Exp length = new CALL(new NAME(typechecker.getBuiltins().stringLength),
                new ExpList (var.getAccess().exp(new TEMP(typechecker.getCurrentMethod().getFrame().FP()))));
        return new ExprType(new Ex(length), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary n) {
        if (n instanceof ANewarrayPrimary) return process((ANewarrayPrimary)n);
	else if (n instanceof APrimary2Primary) return process((APrimary2Primary)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PPrimary)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANewarrayPrimary n) {
        n.getNew();				// yields TNew
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType withinBrackets = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        Type type = typechecker.getType(n.getId());
        type = typechecker.makeArrayType(type, n.getId());
        for (PEmptydim p : n.getEmptydim()) {
            process(p);				// process(PEmptydim)
            type = typechecker.makeArrayType(type, n.getId());
        }
        if (!withinBrackets.getType().equals(Type.intType)) {
            throw new TypecheckerException(n.getId(), "No number in brackets");
        }
        if (!typechecker.checkVarType(n.getId())) {
            throw new TypecheckerException(n.getId(), "Invalid type");
        }
        return new ExprType(new Ex(new CALL(new NAME(typechecker.getBuiltins().createArray),
                new ExpList (withinBrackets.getExpr().unEx()))), type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimary2Primary n) {
        return process(n.getPrimary2());			// process(PPrimary2)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary2 n) {
        if (n instanceof AIconstPrimary2) return process((AIconstPrimary2)n);
	else if (n instanceof ASconstPrimary2) return process((ASconstPrimary2)n);
	else if (n instanceof ANullPrimary2) return process((ANullPrimary2)n);
	else if (n instanceof ATruePrimary2) return process((ATruePrimary2)n);
	else if (n instanceof AFalsePrimary2) return process((AFalsePrimary2)n);
	else if (n instanceof AParensPrimary2) return process((AParensPrimary2)n);
	else if (n instanceof ACallPrimary2) return process((ACallPrimary2)n);
	else if (n instanceof AArrayrefPrimary2) return process((AArrayrefPrimary2)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PPrimary2)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIconstPrimary2 n) {
        n.getIconst();				// yields TIconst
        return new ExprType(new Ex(new CONST(Integer.parseInt(n.getIconst().getText()))), Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ASconstPrimary2 n) {
        n.getSconst();				// yields TSconst
        Label stringLabel = typechecker.addSConst(n.getSconst().toString());
        //@TODO check 11/17 not sure about this one 11/20 Don't think NAME is the right call here
        Exp string = new NAME(stringLabel);
        return new ExprType(new Ex(string), Type.stringType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANullPrimary2 n) {
        n.getNull();				// yields TNull
        //@TODO
        return new ExprType(new Ex(new CONST(0)), Type.nullType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATruePrimary2 n) {
        n.getTrue();				// yields TTrue
        //@TODO check this
        return new ExprType(new Ex(new CONST(1)), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFalsePrimary2 n) {
        n.getFalse();				// yields TFalse
        //@TODO check this
        return new ExprType(new Ex(new CONST(0)), Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AParensPrimary2 n) {
        n.getLparen();				// yields TLparen
        n.getRparen();				// yields TRparen
        return process(n.getExpr());			// process(PExpr)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ACallPrimary2 n) {
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        List<ExprType> exprTypeList = new ArrayList<>();
        if (n.getArglist() != null)
            exprTypeList = process(n.getArglist());		// process(PArglist)
        n.getRparen();				// yields TRparen
        List<Type> typeList = new ArrayList<>();
        ExpList args = new ExpList();
        for (ExprType exprType : exprTypeList){
            typeList.add(exprType.getType());
            args.addLast(exprType.getExpr().unEx());
        }
        List<Method> methodList = typechecker.findMethods(n.getId().getText(), typeList);
        if (methodList.size() > 1) {
            throw new TypecheckerException(n.getId(), "Ambiguous method");
        } else if (methodList.isEmpty()) {
            throw new TypecheckerException(n.getId(), "Method not declared");
        }
        Exp methodName = new NAME(methodList.get(0).getMethodLabel());
        Exp call = new CALL(methodName, args);
        return new ExprType(new Ex(call), methodList.get(0).getReturnType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefPrimary2 n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArrayref n) {
        if (n instanceof ANameArrayref) return process((ANameArrayref)n);
	else if (n instanceof APrimaryArrayref) return process((APrimaryArrayref)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PArrayref)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANameArrayref n) {
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        Var var = typechecker.localST.lookup(n.getId().getText());
        if (var == null) {
            var = typechecker.globalST.get(n.getId().getText());
            if (var == null || (!(var.getType() instanceof ArrayType))) {
                throw new TypecheckerException(n.getLbrack(), "Variable not found");
            }
        } else if (!(var.getType() instanceof ArrayType)){
            throw new TypecheckerException(n.getLbrack(), "Variable is not an array");
        }
        ExprType withinBrackets = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        if (!withinBrackets.getType().equals(Type.intType)) {
            throw new TypecheckerException(n.getId(), "Not a number within the brackets");
        }
        Exp index = new BINOP ("MUL", new CONST(typechecker.getMachine().wordSize()), withinBrackets.getExpr().unEx());
        Exp pointer = var.getAccess().exp(new TEMP(typechecker.getCurrentMethod().getFrame().FP()));
        return new ExprType(new Ex(new MEM(new BINOP("PLUS", index, pointer))), ((ArrayType) var.getType()).getBaseType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryArrayref n) {
        ExprType arrayType = process(n.getPrimary2());			// process(PPrimary2)
        n.getLbrack();				// yields TLbrack
        ExprType inner = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        if (inner.getType() != Type.intType) {
            throw new TypecheckerException(n.getLbrack(), "Incompatible type.");
        }
        Exp index = new BINOP ("MUL", new CONST(typechecker.getMachine().wordSize()), inner.getExpr().unEx());
        Exp pointer = arrayType.getExpr().unEx();
        return new ExprType(new Ex(new MEM(new BINOP("PLUS", index, pointer))), ((ArrayType) arrayType.getType()).getBaseType());
    }


    ///////////////////////////////////////////////////////////////
    ExprType process(PLhs n) {
        if (n instanceof AIdLhs) return process((AIdLhs)n);
	else if (n instanceof AArrayrefLhs) return process((AArrayrefLhs)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PLhs)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdLhs n) {
        n.getId();				// yields TId
        Var lhsVar = typechecker.localST.lookup(n.getId().getText());
        if (lhsVar == null) {
            lhsVar = typechecker.globalST.get(n.getId().getText());
            if (lhsVar == null) {
                throw new TypecheckerException(n.getId(), "Cannot find symbol.");
            }
        }
        //@TODO--How questionable is this?
        Exp mem = (lhsVar.getAccess().exp(new TEMP(typechecker.getCurrentMethod().getFrame().FP())));
        return new ExprType(new Ex(mem), lhsVar.getType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefLhs n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(PArglist n) {
        if (n instanceof AListArglist) return process((AListArglist)n);
	    else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PArglist)");
    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(AListArglist n) {
        List<ExprType> typeList = new ArrayList<>();
        typeList.add(process(n.getExpr()));			// process(PExpr)
        for (PArg p : n.getArg())
            typeList.add(process(p));				// process(PArg)
        return typeList;
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArg n) {
        if (n instanceof AArg) return process((AArg)n);
	    else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PArg)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArg n) {
        n.getComma();				// yields TComma
        return process(n.getExpr());			// process(PExpr)
    }

    ///////////////////////////////////////////////////////////////
    void process(PEmptydim n) {
        if (n instanceof AEmptydim) process((AEmptydim)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PEmptydim)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptydim n) {
        n.getLbrack();				// yields TLbrack
        n.getRbrack();				// yields TRbrack
    }

}
