/* This file was generated by the Amherst version of SableCC */

/*  TODO: Things we do not understand:
    #7 - A variable that holds the return value.  When the code hits a return insert the value of the return into the
    variable and jump to the end of the method which then fetches the value inside of the variable and returns it
    Change stmt processes to return stmts.
    Change exprType processes so they return Expr
    Figure which Expr to return
    Initialize Access in HiddenVariable
    Initialize Accesses in general
    Bit of memory (get it?) that we don't understand
    Implement Stm building in Method.
*/
package minijava.Typechecker;

import minijava.Translate.*;
import minijava.node.*;
import minijava.Type.*;
import minijava.Frame.*;
import minijava.Temp.*;
import minijava.Tree.*;

import java.util.List;
import java.util.ArrayList;

public class Phase2
{
    private Typechecker typechecker;

    Phase2(Typechecker typechecker) {
        this.typechecker = typechecker;
    }

    void process(Node n) {
    	 throw new RuntimeException(this.getClass() + ": no process method available for "
	     + n.getClass());
    }

    ///////////////////////////////////////////////////////////////
    void process(Start n) {
         process(n.getPProgram());
    }

    ///////////////////////////////////////////////////////////////
    void process(PProgram n) {
        if (n instanceof AProgram) process((AProgram)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AProgram n) {
        n.getPublic();				// yields TPublic
        n.getClasstok();				// yields TClasstok
        n.getId();				// yields TId
        n.getLbrace();				// yields TLbrace
        for (PMaindecl p : n.getMaindecl())
            process(p);				// process(PMaindecl)
        n.getRbrace();				// yields TRbrace
    }

    ///////////////////////////////////////////////////////////////
    void process(PMaindecl n) {
        if (n instanceof AVarMaindecl) process((AVarMaindecl)n);
	else if (n instanceof AMethodMaindecl) process((AMethodMaindecl)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AVarMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi
        Var var = typechecker.createClassVar(n.getId().getText(), process(n.getType()));
        Label label = typechecker.getMachine().makeLabel(n.getId().getText());
        var.setLabel(label);
    }

    ///////////////////////////////////////////////////////////////
    void process(AMethodMaindecl n) {
        typechecker.nextMethod();
        Method method = typechecker.getCurrentMethod();
        Label label = typechecker.getMachine().makeLabel(n.getId().getText());
        method.setMethodLabel(label);
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        typechecker.localST.increaseScope();
        process(n.getParamlist());			// process(PParamlist)
        method.makeFrame(typechecker.getMachine());
        n.getRparen();				// yields TRparen
        n.getLbrace();				// yields TLbrace
        Label l1 = new Label();
        method.setExitLabel(l1);
        for (PStmt p : n.getStmt())
            process(p);				// process(PStmt)
        //TODO Add these tree fragments to method
//        MOVE move = new MOVE(method.getFrame().RV(), method.getHiddenVar().getAccess().exp(method.getFrame().FP()));
//        new MEM(method.getHiddenVar().getAccess().exp(method.getFrame().FP()));
//        TODO: Determine what is being returned in the TEMP with reg to it. See if you need to add the FP or SP to get the right thing.
//        And put it in the MOVE. Also we need to figure out how to initialize the Access in Hidden Variable.
        LABEL exitLabel = new LABEL(l1);
        n.getRbrace();				// yields TRbrace
        typechecker.localST.decreaseScope();
    }

    ///////////////////////////////////////////////////////////////
    void process(PParamlist n) {
        if (n instanceof AListParamlist) process((AListParamlist)n);
        else if (n instanceof AEmptyParamlist) process((AEmptyParamlist)n);
        else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PParamlist)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AListParamlist n) {
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        typechecker.localST.declareLocal(n.getId().getText(), process(n.getType()));
        for (PParam p : n.getParam())
            process(p);				// process(PParam)
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptyParamlist n) {
    }

    ///////////////////////////////////////////////////////////////
    void process(PParam n) {
        if (n instanceof AParam) process((AParam)n);
	    else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PParam)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AParam n) {
        n.getComma();				// yields TComma
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        typechecker.localST.declareLocal(n.getId().getText(), process(n.getType()));
    }

    ///////////////////////////////////////////////////////////////
    void process(PPrivacy n) {
        if (n instanceof APublicPrivacy) process((APublicPrivacy)n);
	else if (n instanceof ABlankPrivacy) process((ABlankPrivacy)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PPrivacy)");
    }

    ///////////////////////////////////////////////////////////////
    void process(APublicPrivacy n) {
        n.getPublic();				// yields TPublic
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlankPrivacy n) {
    }

    ///////////////////////////////////////////////////////////////
    Type process(PType n) {
        if (n instanceof AType) return process((AType)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PType)");
    }

    ///////////////////////////////////////////////////////////////
    Type process(AType n) {
        Type type = typechecker.getType(n.getId());
        for (PEmptydim p : n.getEmptydim())
            type = typechecker.makeArrayType(type, n.getId());
        System.out.println("Type is "+type);
        return type;
    }

    ///////////////////////////////////////////////////////////////
    void process(PStmt n) {
        if (n instanceof AWhileStmt) process((AWhileStmt)n);
	else if (n instanceof ADeclStmt) process((ADeclStmt)n);
	else if (n instanceof ABlockStmt) process((ABlockStmt)n);
	else if (n instanceof AIfStmt) process((AIfStmt)n);
	else if (n instanceof AExprStmt) process((AExprStmt)n);
	else if (n instanceof AReturnStmt) process((AReturnStmt)n);
	else if (n instanceof APrintStmt) process((APrintStmt)n);
	else if (n instanceof AEmptyStmt) process((AEmptyStmt)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PStmt)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AWhileStmt n) {
        n.getWhile();				// yields TWhile
        n.getLparen();				// yields TLparen
        if (!process(n.getExpr()).getType().equals(Type.booleanType))			// process(PExpr)
            throw new TypecheckerException(n.getLparen(), "Incompatible type");
        n.getRparen();				// yields TRparen
        typechecker.localST.increaseScope();
        process(n.getStmt());			// process(PStmt)
        typechecker.localST.decreaseScope();
    }

    ///////////////////////////////////////////////////////////////
    void process(ADeclStmt n) {
        Type type = process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi
        boolean declared = typechecker.localST.declareLocal(n.getId().getText(), type);
        if (!declared) {
            throw new TypecheckerException(n.getId(), "A variable of the same name has already been declared.");
        }
        Access access = typechecker.getCurrentMethod().getFrame().allocLocal();
        typechecker.localST.lookup(n.getId().getText()).setAccess(access);
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlockStmt n) {
        n.getLbrace();				// yields TLbrace
        for (PStmt p : n.getStmt())
            process(p);				// process(PStmt)
        n.getRbrace();				// yields TRbrace
    }

    ///////////////////////////////////////////////////////////////
    void process(AIfStmt n) {
        n.getIf();				// yields TIf
        n.getLparen();				// yields TLparen
        if (!process(n.getExpr()).getType().equals(Type.booleanType))			// process(PExpr)
            throw new TypecheckerException(n.getLparen(), "Incompatible type");
        n.getRparen();				// yields TRparen
        typechecker.localST.increaseScope();
        process(n.getThenclause());			// process(PStmt)
        typechecker.localST.decreaseScope();
        n.getElse();				// yields TElse
        typechecker.localST.increaseScope();
        process(n.getElseclause());			// process(PStmt)
        typechecker.localST.decreaseScope();
    }

    ///////////////////////////////////////////////////////////////
    void process(AExprStmt n) {
        process(n.getExpr());			// process(PExpr)
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    Stm process(AReturnStmt n) {
        n.getReturn();				// yields TReturn
        n.getSemi();				// yields TSemi
        Type type = Type.voidType;
        ExprType exprType;
        if (n.getExpr() != null) {
            exprType = process(n.getExpr());		// process(PExpr)
            type = exprType.getType();
        }
        Type returnType = typechecker.getCurrentMethod().getReturnType();
        if (!type.canAssignTo(returnType)) {
            throw new TypecheckerException(n.getReturn(), "Return type is not valid");
        }
        Method method = typechecker.getCurrentMethod();
        if (returnType.equals(Type.voidType) && type.equals(returnType)){
            return new JUMP(method.getExitLabel());
        } else {
//            MOVE move = new MOVE(method.getHidden().getFrame().allocLocal().exp(new TEMP(method.getFrame().FP())), exprType.unEx());
//            JUMP jump = new JUMP(method.getExitLabel());
//            SEQ seq = new SEQ(move, jump);
//            return seq;
            return null;
            //@TODO Uncomment this when unEx() is implemented;
        }
    }

    ///////////////////////////////////////////////////////////////
    void process(APrintStmt n) {
        n.getPrint();				// yields TPrint
        n.getLparen();				// yields TLparen
        if (process(n.getExpr()).getType().equals(Type.voidType)) {
            throw new TypecheckerException(n.getLparen(), "type not allowed here");
        }
        n.getRparen();				// yields TRparen
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptyStmt n) {
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr n) {
        if (n instanceof AAssignExpr) return process((AAssignExpr)n);
	else if (n instanceof AExprExpr) return process((AExprExpr)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AAssignExpr n) {
        ExprType lhs = process(n.getLhs());			// process(PLhs)
        ExprType rhs = process(n.getExpr());			// process(PExpr)
        if (!(rhs.getType().canAssignTo(lhs.getType()))){
            throw new TypecheckerException(n.getAssign(), "Incompatible types.");
        }
        return lhs;
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr n) {
        return process(n.getExpr10());			// process(PExpr10)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr10 n) {
        if (n instanceof AOrExpr10) return process((AOrExpr10)n);
	else if (n instanceof AExprExpr10) return process((AExprExpr10)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr10)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AOrExpr10 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr10)
        n.getOr();				// yields TOr
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr20)
        if ((!typeLHS.equals(Type.booleanType)) || (!typeRHS.equals(Type.booleanType))){
            throw new TypecheckerException(n.getOr(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr10 n) {
        return process(n.getExpr20());			// process(PExpr20)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr20 n) {
        if (n instanceof AAndExpr20) return process((AAndExpr20)n);
	else if (n instanceof AExprExpr20) return process((AExprExpr20)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr20)");

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AAndExpr20 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr20)
        n.getAnd();				// yields TAnd
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr30)
        if ((!typeLHS.equals(Type.booleanType)) || (!typeRHS.equals(Type.booleanType))){
            throw new TypecheckerException(n.getAnd(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr20 n) {
        return process(n.getExpr30());			// process(PExpr30)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr30 n) {
        if (n instanceof AEqExpr30) return process((AEqExpr30)n);
	else if (n instanceof ANeExpr30) return process((ANeExpr30)n);
	else if (n instanceof AExprExpr30) return process((AExprExpr30)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr30)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AEqExpr30 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr30)
        n.getEq();				// yields TEq
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr40)
        if ((!typeLHS.canAssignTo(typeRHS)) && (!typeRHS.canAssignTo(typeLHS))){
            throw new TypecheckerException(n.getEq(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANeExpr30 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr30)
        n.getNe();				// yields TNe
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr40)
        if ((!typeLHS.canAssignTo(typeRHS)) && (!typeRHS.canAssignTo(typeLHS))){
            throw new TypecheckerException(n.getNe(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr30 n) {
        return process(n.getExpr40());			// process(PExpr40)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr40 n) {
        if (n instanceof ALtExpr40) return process((ALtExpr40)n);
	else if (n instanceof ALeExpr40) return process((ALeExpr40)n);
	else if (n instanceof AGeExpr40) return process((AGeExpr40)n);
	else if (n instanceof AGtExpr40) return process((AGtExpr40)n);
	else if (n instanceof AExprExpr40) return process((AExprExpr40)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr40)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALtExpr40 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr40)
        n.getLt();				// yields TLt
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr50)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType))){
            throw new TypecheckerException(n.getLt(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALeExpr40 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr40)
        n.getLe();				// yields TLe
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr50)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType))){
            throw new TypecheckerException(n.getLe(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AGeExpr40 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr40)
        n.getGe();				// yields TGe
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr50)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType))){
            throw new TypecheckerException(n.getGe(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AGtExpr40 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr40)
        n.getGt();				// yields TGt
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr50)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType))){
            throw new TypecheckerException(n.getGt(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr40 n) {
        return process(n.getExpr50());			// process(PExpr50)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr50 n) {
        if (n instanceof APlusExpr50) return process((APlusExpr50)n);
	else if (n instanceof AMinusExpr50) return process((AMinusExpr50)n);
	else if (n instanceof ATermExpr50) return process((ATermExpr50)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PExpr50)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APlusExpr50 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr50)
        n.getPlus();				// yields TPlus
        Type typeRHS = process(n.getRight()).getType();			// process(PTerm)
        Type type = typeLHS;
        if (typeLHS.equals(Type.stringType)){
            if (typeRHS.equals(Type.voidType)){
                throw new TypecheckerException(n.getPlus(), "Incompatible types");
            }
        }
        else if (typeRHS.equals(Type.stringType)){
            if (typeLHS.equals(Type.voidType)){
                throw new TypecheckerException(n.getPlus(), "Incompatible types");
            }
        }
        else if (typeLHS.equals(Type.intType)){
            if (!( typeRHS.equals(Type.intType))){
                throw new TypecheckerException(n.getPlus(), "Incompatible types");
            }
        }
        if (!typeLHS.equals(typeRHS)){
            type = Type.stringType;
        }
        return new ExprType(null, type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AMinusExpr50 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr50)
        n.getMinus();				// yields TMinus
        Type typeRHS = process(n.getRight()).getType();			// process(PTerm)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType)))
        {
            throw new TypecheckerException(n.getMinus(), "Incompatible types");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATermExpr50 n) {
        return process(n.getTerm());			// process(PTerm)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PTerm n) {
        if (n instanceof ATimesTerm) return process((ATimesTerm)n);
	else if (n instanceof ADivTerm) return process((ADivTerm)n);
	else if (n instanceof AModTerm) return process((AModTerm)n);
	else if (n instanceof AFactorTerm) return process((AFactorTerm)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PTerm)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATimesTerm n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PTerm)
        n.getTimes();				// yields TTimes
        Type typeRHS = process(n.getRight()).getType();			// process(PFactor)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType)))
        {
            throw new TypecheckerException(n.getTimes(), "Incompatible types");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ADivTerm n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PTerm)
        n.getDiv();				// yields TDiv
        Type typeRHS = process(n.getRight()).getType();			// process(PFactor)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType)))
        {
            throw new TypecheckerException(n.getDiv(), "Incompatible types");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AModTerm n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PTerm)
        n.getMod();				// yields TMod
        Type typeRHS = process(n.getRight()).getType();			// process(PFactor)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType)))
        {
            throw new TypecheckerException(n.getMod(), "Incompatible types");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFactorTerm n) {
        return process(n.getFactor());			// process(PFactor)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PFactor n) {
        if (n instanceof APrimaryFactor) return process((APrimaryFactor)n);
	else if (n instanceof AIdFactor) return process((AIdFactor)n);
	else if (n instanceof ALengthFactor) return process((ALengthFactor)n);
	else if (n instanceof ALength2Factor) return process((ALength2Factor)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PFactor)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryFactor n) {
        return process(n.getPrimary());			// process(PPrimary)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdFactor n) {
        n.getId();				// yields TId
        Var var = typechecker.localST.lookup(n.getId().getText());
        if (var==null){
            var = typechecker.globalST.get(n.getId().getText());
            if (var==null){
                throw new TypecheckerException(n.getId(), "Variable not declared");
            }
        }
        return new ExprType(null, var.getType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALengthFactor n) {
        n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        if (!(typechecker.localST.lookup(n.getId().getText()).getType() instanceof ArrayType)) {
            throw new TypecheckerException(n.getId(), "Is not an array");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALength2Factor n) {
        n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        n.getLparen();				// yields TLparen
        n.getRparen();				// yields TRparen
        if (!((typechecker.localST.lookup(n.getId().getText())).getType().equals(Type.stringType))) {
            throw new TypecheckerException(n.getId(), "Is not a String");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary n) {
        if (n instanceof ANewarrayPrimary) return process((ANewarrayPrimary)n);
	else if (n instanceof APrimary2Primary) return process((APrimary2Primary)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PPrimary)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANewarrayPrimary n) {
        n.getNew();				// yields TNew
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType withinBrackets = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        Type type = typechecker.getType(n.getId());
        type = typechecker.makeArrayType(type, n.getId());
        for (PEmptydim p : n.getEmptydim()) {
            process(p);				// process(PEmptydim)
            type = typechecker.makeArrayType(type, n.getId());
        }
        if (!withinBrackets.getType().equals(Type.intType)) {
            throw new TypecheckerException(n.getId(), "No number in brackets");
        }
        if (!typechecker.checkVarType(n.getId())) {
            throw new TypecheckerException(n.getId(), "Invalid type");
        }
        return new ExprType(null, type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimary2Primary n) {
        return process(n.getPrimary2());			// process(PPrimary2)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary2 n) {
        if (n instanceof AIconstPrimary2) return process((AIconstPrimary2)n);
	else if (n instanceof ASconstPrimary2) return process((ASconstPrimary2)n);
	else if (n instanceof ANullPrimary2) return process((ANullPrimary2)n);
	else if (n instanceof ATruePrimary2) return process((ATruePrimary2)n);
	else if (n instanceof AFalsePrimary2) return process((AFalsePrimary2)n);
	else if (n instanceof AParensPrimary2) return process((AParensPrimary2)n);
	else if (n instanceof ACallPrimary2) return process((ACallPrimary2)n);
	else if (n instanceof AArrayrefPrimary2) return process((AArrayrefPrimary2)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PPrimary2)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIconstPrimary2 n) {
        n.getIconst();				// yields TIconst
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ASconstPrimary2 n) {
        n.getSconst();				// yields TSconst
        return new ExprType(null, Type.stringType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANullPrimary2 n) {
        n.getNull();				// yields TNull
        return new ExprType(null, Type.nullType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATruePrimary2 n) {
        n.getTrue();				// yields TTrue
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFalsePrimary2 n) {
        n.getFalse();				// yields TFalse
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AParensPrimary2 n) {
        n.getLparen();				// yields TLparen
        n.getRparen();				// yields TRparen
        return process(n.getExpr());			// process(PExpr)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ACallPrimary2 n) {
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        List<ExprType> exprTypeList = new ArrayList<>();
        if (n.getArglist() != null)
            exprTypeList = process(n.getArglist());		// process(PArglist)
        n.getRparen();				// yields TRparen
        List<Type> typeList = new ArrayList<>();
        for (ExprType exprType : exprTypeList){
            typeList.add(exprType.getType());
        }
        List<Method> methodList = typechecker.findMethods(n.getId().getText(), typeList);
        if (methodList.size() > 1) {
            throw new TypecheckerException(n.getId(), "Ambiguous method");
        } else if (methodList.isEmpty()) {
            throw new TypecheckerException(n.getId(), "Method not declared");
        }
        return new ExprType(null, methodList.get(0).getReturnType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefPrimary2 n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArrayref n) {
        if (n instanceof ANameArrayref) return process((ANameArrayref)n);
	else if (n instanceof APrimaryArrayref) return process((APrimaryArrayref)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PArrayref)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANameArrayref n) {
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType withinBrackets = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        if (!withinBrackets.getType().equals(Type.intType)) {
            throw new TypecheckerException(n.getId(), "Not a number within the brackets");
        }
        Var var = typechecker.localST.lookup(n.getId().getText());
        if (var == null || (!(var.getType() instanceof ArrayType))) {
            var = typechecker.globalST.get(n.getId().getText());
            if (var == null || (!(var.getType() instanceof ArrayType))) {
                throw new TypecheckerException(n.getLbrack(), "Variable not found");
            }
        }
        if (var.getType() instanceof ArrayType){
            return new ExprType(null, ((ArrayType) var.getType()).getBaseType());
        }
        else {
            return new ExprType(null, var.getType());
        }
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryArrayref n) {
        ExprType arrayType = process(n.getPrimary2());			// process(PPrimary2)
        n.getLbrack();				// yields TLbrack
        ExprType inner = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        if (inner.getType() != Type.intType) {
            throw new TypecheckerException(n.getLbrack(), "Incompatible type.");
        }
        return new ExprType(null, ((ArrayType) arrayType.getType()).getBaseType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PLhs n) {
        if (n instanceof AIdLhs) return process((AIdLhs)n);
	else if (n instanceof AArrayrefLhs) return process((AArrayrefLhs)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PLhs)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdLhs n) {
        n.getId();				// yields TId
        Var lhsVar = typechecker.localST.lookup(n.getId().getText());
        if (lhsVar == null) {
            lhsVar = typechecker.globalST.get(n.getId().getText());
            if (lhsVar == null) {
                throw new TypecheckerException(n.getId(), "Cannot find symbol.");
            }
        }
        return new ExprType(null, lhsVar.getType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefLhs n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(PArglist n) {
        if (n instanceof AListArglist) return process((AListArglist)n);
	    else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PArglist)");
    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(AListArglist n) {
        List<ExprType> typeList = new ArrayList<>();
        typeList.add(process(n.getExpr()));			// process(PExpr)
        for (PArg p : n.getArg())
            typeList.add(process(p));				// process(PArg)
        return typeList;
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArg n) {
        if (n instanceof AArg) return process((AArg)n);
	    else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PArg)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArg n) {
        n.getComma();				// yields TComma
        return process(n.getExpr());			// process(PExpr)
    }

    ///////////////////////////////////////////////////////////////
    void process(PEmptydim n) {
        if (n instanceof AEmptydim) process((AEmptydim)n);
	else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PEmptydim)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptydim n) {
        n.getLbrack();				// yields TLbrack
        n.getRbrack();				// yields TRbrack
    }

}
