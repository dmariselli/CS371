/* This file was generated by the Amherst version of SableCC */

package minijava.Typechecker;

import minijava.node.*;
import minijava.Type.*;

public class Phase2
{

    private Typechecker typechecker;

    Phase2(Typechecker typechecker) {
        this.typechecker = typechecker;
    }

    void process(Node n) {
    	 throw new RuntimeException(this.getClass() + ": no process method available for " 
	     + n.getClass());
    }

    ///////////////////////////////////////////////////////////////
    void process(Start n) {
         process(n.getPProgram());
    }

    ///////////////////////////////////////////////////////////////
    void process(PProgram n) {
        if (n instanceof AProgram) process((AProgram)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PProgram)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AProgram n) {
        n.getPublic();				// yields TPublic
        n.getClasstok();				// yields TClasstok
        n.getId();				// yields TId
        n.getLbrace();				// yields TLbrace
	for (PMaindecl p : n.getMaindecl())
	    process(p);				// process(PMaindecl)
        n.getRbrace();				// yields TRbrace

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(PMaindecl n) {
        if (n instanceof AVarMaindecl) process((AVarMaindecl)n);
	else if (n instanceof AMethodMaindecl) process((AMethodMaindecl)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PMaindecl)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AVarMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AMethodMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        process(n.getParamlist());			// process(PParamlist)
        n.getRparen();				// yields TRparen
        n.getLbrace();				// yields TLbrace
        typechecker.localST.increaseScope();
	for (PStmt p : n.getStmt())
	    process(p);				// process(PStmt)
        n.getRbrace();				// yields TRbrace
        typechecker.localST.decreaseScope();

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(PParamlist n) {
        if (n instanceof AListParamlist) process((AListParamlist)n);
	else if (n instanceof AEmptyParamlist) process((AEmptyParamlist)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PParamlist)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AListParamlist n) {
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
	for (PParam p : n.getParam())
	    process(p);				// process(PParam)

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptyParamlist n) {

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(PParam n) {
        if (n instanceof AParam) process((AParam)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PParam)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AParam n) {
        n.getComma();				// yields TComma
        process(n.getType());			// process(PType)
        n.getId();				// yields TId

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(PPrivacy n) {
        if (n instanceof APublicPrivacy) process((APublicPrivacy)n);
	else if (n instanceof ABlankPrivacy) process((ABlankPrivacy)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrivacy)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(APublicPrivacy n) {
        n.getPublic();				// yields TPublic

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlankPrivacy n) {

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    Type process(PType n) {
        if (n instanceof AType) return process((AType)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PType)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    Type process(AType n) {
        Type type = typechecker.getType(n.getId());
        for (PEmptydim p : n.getEmptydim())
            type = typechecker.makeArrayType(type, n.getId());
        return type;
//        n.getId();				// yields TId
//	for (PEmptydim p : n.getEmptydim())
//	    process(p);				// process(PEmptydim)

    }

    ///////////////////////////////////////////////////////////////
    void process(PStmt n) {
        if (n instanceof AWhileStmt) process((AWhileStmt)n);
	else if (n instanceof ADeclStmt) process((ADeclStmt)n);
	else if (n instanceof ABlockStmt) process((ABlockStmt)n);
	else if (n instanceof AIfStmt) process((AIfStmt)n);
	else if (n instanceof AExprStmt) process((AExprStmt)n);
	else if (n instanceof AReturnStmt) process((AReturnStmt)n);
	else if (n instanceof APrintStmt) process((APrintStmt)n);
	else if (n instanceof AEmptyStmt) process((AEmptyStmt)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PStmt)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AWhileStmt n) {
        n.getWhile();				// yields TWhile
        n.getLparen();				// yields TLparen
        process(n.getExpr());			// process(PExpr)
        n.getRparen();				// yields TRparen
        process(n.getStmt());			// process(PStmt)

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(ADeclStmt n) {
        Type type = process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi
        typechecker.localST.declareLocal(n.getId().getText(), type);

        //@TODO I WANT TO BE ABLE TO PUT VARIABLE INTO SYMBOL TABLE HERE
        //But I can't because I have no type T_T
        //Process is like void n all
        //Type thing is AType

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlockStmt n) {
        n.getLbrace();				// yields TLbrace
	for (PStmt p : n.getStmt())
	    process(p);				// process(PStmt)
        n.getRbrace();				// yields TRbrace

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AIfStmt n) {
        n.getIf();				// yields TIf
        n.getLparen();				// yields TLparen
        process(n.getExpr());			// process(PExpr)
        n.getRparen();				// yields TRparen
        process(n.getThenclause());			// process(PStmt)
        n.getElse();				// yields TElse
        process(n.getElseclause());			// process(PStmt)

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AExprStmt n) {
        process(n.getExpr());			// process(PExpr)
        n.getSemi();				// yields TSemi

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AReturnStmt n) {
        n.getReturn();				// yields TReturn
        if (n.getExpr() != null)
            process(n.getExpr());		// process(PExpr)
        n.getSemi();				// yields TSemi

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(APrintStmt n) {
        n.getPrint();				// yields TPrint
        n.getLparen();				// yields TLparen
        process(n.getExpr());			// process(PExpr)
        n.getRparen();				// yields TRparen
        n.getSemi();				// yields TSemi

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptyStmt n) {
        n.getSemi();				// yields TSemi

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    // Everything below this should return ExprType
    // return new ExprType (null, *type*);
    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr n) {
        if (n instanceof AAssignExpr) return process((AAssignExpr)n);
	else if (n instanceof AExprExpr) return process((AExprExpr)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AAssignExpr n) {
        return process(n.getLhs());			// process(PLhs)  <- this one
        n.getAssign();				// yields TAssign
        process(n.getExpr());			// process(PExpr)  < not this one
        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr n) {
        return process(n.getExpr10());			// process(PExpr10)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr10 n) {
        if (n instanceof AOrExpr10) return process((AOrExpr10)n);
	else if (n instanceof AExprExpr10) return process((AExprExpr10)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr10)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AOrExpr10 n) {
        process(n.getLeft());			// process(PExpr10)
        n.getOr();				// yields TOr
        process(n.getRight());			// process(PExpr20)
        //TODO check bools
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr10 n) {
        return process(n.getExpr20());			// process(PExpr20)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr20 n) {
        if (n instanceof AAndExpr20) return process((AAndExpr20)n);
	else if (n instanceof AExprExpr20) return process((AExprExpr20)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr20)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AAndExpr20 n) {
        process(n.getLeft());			// process(PExpr20)
        n.getAnd();				// yields TAnd
        process(n.getRight());			// process(PExpr30)
        //TODO check bools
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr20 n) {
        return process(n.getExpr30());			// process(PExpr30)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr30 n) {
        if (n instanceof AEqExpr30) return process((AEqExpr30)n);
	else if (n instanceof ANeExpr30) return process((ANeExpr30)n);
	else if (n instanceof AExprExpr30) return process((AExprExpr30)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr30)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AEqExpr30 n) {
        process(n.getLeft());			// process(PExpr30)
        n.getEq();				// yields TEq
        process(n.getRight());			// process(PExpr40)
        //TODO check bools
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANeExpr30 n) {
        process(n.getLeft());			// process(PExpr30)
        n.getNe();				// yields TNe
        process(n.getRight());			// process(PExpr40)
        //TODO check bools
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr30 n) {
        return process(n.getExpr40());			// process(PExpr40)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr40 n) {
        if (n instanceof ALtExpr40) return process((ALtExpr40)n);
	else if (n instanceof ALeExpr40) return process((ALeExpr40)n);
	else if (n instanceof AGeExpr40) return process((AGeExpr40)n);
	else if (n instanceof AGtExpr40) return process((AGtExpr40)n);
	else if (n instanceof AExprExpr40) return process((AExprExpr40)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr40)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALtExpr40 n) {
        process(n.getLeft());			// process(PExpr40)
        n.getLt();				// yields TLt
        process(n.getRight());			// process(PExpr50)
        //TODO check bools
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALeExpr40 n) {
        process(n.getLeft());			// process(PExpr40)
        n.getLe();				// yields TLe
        process(n.getRight());			// process(PExpr50)
        //TODO check bools
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AGeExpr40 n) {
        process(n.getLeft());			// process(PExpr40)
        n.getGe();				// yields TGe
        process(n.getRight());			// process(PExpr50)
        //TODO check bools
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AGtExpr40 n) {
        process(n.getLeft());			// process(PExpr40)
        n.getGt();				// yields TGt
        process(n.getRight());			// process(PExpr50)
        //TODO check bools
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr40 n) {
        return process(n.getExpr50());			// process(PExpr50)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr50 n) {
        if (n instanceof APlusExpr50) return process((APlusExpr50)n);
	else if (n instanceof AMinusExpr50) return process((AMinusExpr50)n);
	else if (n instanceof ATermExpr50) return process((ATermExpr50)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr50)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APlusExpr50 n) {
        process(n.getLeft());			// process(PExpr50)
        n.getPlus();				// yields TPlus
        process(n.getRight());			// process(PTerm)
        //TODO check bools
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AMinusExpr50 n) {
        process(n.getLeft());			// process(PExpr50)
        n.getMinus();				// yields TMinus
        process(n.getRight());			// process(PTerm)
        //TODO check bools
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATermExpr50 n) {
        return process(n.getTerm());			// process(PTerm)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PTerm n) {
        if (n instanceof ATimesTerm) return process((ATimesTerm)n);
	else if (n instanceof ADivTerm) return process((ADivTerm)n);
	else if (n instanceof AModTerm) return process((AModTerm)n);
	else if (n instanceof AFactorTerm) return process((AFactorTerm)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PTerm)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATimesTerm n) {
        process(n.getLeft());			// process(PTerm)
        n.getTimes();				// yields TTimes
        process(n.getRight());			// process(PFactor)
        //TODO check values
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ADivTerm n) {
        process(n.getLeft());			// process(PTerm)
        n.getDiv();				// yields TDiv
        process(n.getRight());			// process(PFactor)
        //TODO check values
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AModTerm n) {
        process(n.getLeft());			// process(PTerm)
        n.getMod();				// yields TMod
        process(n.getRight());			// process(PFactor)
        //TODO check values
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFactorTerm n) {
        return process(n.getFactor());			// process(PFactor)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PFactor n) {
        if (n instanceof APrimaryFactor) return process((APrimaryFactor)n);
	else if (n instanceof AIdFactor) return process((AIdFactor)n);
	else if (n instanceof ALengthFactor) return process((ALengthFactor)n);
	else if (n instanceof ALength2Factor) return process((ALength2Factor)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PFactor)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryFactor n) {
        return process(n.getPrimary());			// process(PPrimary)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdFactor n) {
        n.getId();				// yields TId

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALengthFactor n) {
        n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        //TODO check values
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALength2Factor n) {
        n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        n.getLparen();				// yields TLparen
        n.getRparen();				// yields TRparen
        //TODO check values
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary n) {
        if (n instanceof ANewarrayPrimary) return process((ANewarrayPrimary)n);
	else if (n instanceof APrimary2Primary) return process((APrimary2Primary)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrimary)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANewarrayPrimary n) {
        n.getNew();				// yields TNew
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
	for (PEmptydim p : n.getEmptydim())
	    process(p);				// process(PEmptydim)
        //TODO check values
        //TODO put value in exprType assuming it's value
//        return new ExprType(null, );
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimary2Primary n) {
        return process(n.getPrimary2());			// process(PPrimary2)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary2 n) {
        if (n instanceof AIconstPrimary2) return process((AIconstPrimary2)n);
	else if (n instanceof ASconstPrimary2) return process((ASconstPrimary2)n);
	else if (n instanceof ANullPrimary2) return process((ANullPrimary2)n);
	else if (n instanceof ATruePrimary2) return process((ATruePrimary2)n);
	else if (n instanceof AFalsePrimary2) return process((AFalsePrimary2)n);
	else if (n instanceof AParensPrimary2) return process((AParensPrimary2)n);
	else if (n instanceof ACallPrimary2) return process((ACallPrimary2)n);
	else if (n instanceof AArrayrefPrimary2) return process((AArrayrefPrimary2)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrimary2)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIconstPrimary2 n) {
        n.getIconst();				// yields TIconst
        // TODO check values
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ASconstPrimary2 n) {
        n.getSconst();				// yields TSconst
        // TODO check values
        return new ExprType(null, Type.stringType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANullPrimary2 n) {
        n.getNull();				// yields TNull
        // TODO check values
        return new ExprType(null, Type.nullType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATruePrimary2 n) {
        n.getTrue();				// yields TTrue
        // TODO check values
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFalsePrimary2 n) {
        n.getFalse();				// yields TFalse
        // TODO check values
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AParensPrimary2 n) {
        n.getLparen();				// yields TLparen
        return process(n.getExpr());			// process(PExpr)
        n.getRparen();				// yields TRparen
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ACallPrimary2 n) {
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        if (n.getArglist() != null)
            process(n.getArglist());		// process(PArglist)
        n.getRparen();				// yields TRparen
        // TODO check values
        // TODO lookup on ID :)
        // TODO lookup on argument list :))

//        return new ExprType(null, whatever the method returns);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefPrimary2 n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArrayref n) {
        if (n instanceof ANameArrayref) return process((ANameArrayref)n);
	else if (n instanceof APrimaryArrayref) return process((APrimaryArrayref)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArrayref)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANameArrayref n) {
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        // TODO check type of array
        // TODO check expression returns int
        // TODO check values
//        return new ExprType(null, type of array);
        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryArrayref n) {
        process(n.getPrimary2());			// process(PPrimary2)
        n.getLbrack();				// yields TLbrack
        process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        // TODO check values
        // TODO check pprimary is arrayref
//        return new ExprType(null, whatever the array wants to be);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PLhs n) {
        if (n instanceof AIdLhs) return process((AIdLhs)n);
	else if (n instanceof AArrayrefLhs) return process((AArrayrefLhs)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PLhs)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdLhs n) {
        n.getId();				// yields TId
        // TODO symbol table lookup of type
        // return that ^^

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefLhs n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    // ignore this one
    ///////////////////////////////////////////////////////////////
    void process(PArglist n) {
        if (n instanceof AListArglist) process((AListArglist)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArglist)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }
    // ignore this one
    ///////////////////////////////////////////////////////////////
    void process(AListArglist n) {
        process(n.getExpr());			// process(PExpr)
	for (PArg p : n.getArg())
	    process(p);				// process(PArg)

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArg n) {
        if (n instanceof AArg) return process((AArg)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArg)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArg n) {
        n.getComma();				// yields TComma
        return process(n.getExpr());			// process(PExpr)

        throw new UnsupportedOperationException ();     // remove when method is complete
    }
    // ignore this one
    ///////////////////////////////////////////////////////////////
    void process(PEmptydim n) {
        if (n instanceof AEmptydim) process((AEmptydim)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PEmptydim)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }
    // ignore this one
    ///////////////////////////////////////////////////////////////
    void process(AEmptydim n) {
        n.getLbrack();				// yields TLbrack
        n.getRbrack();				// yields TRbrack

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

}
