/* This file was generated by the Amherst version of SableCC */

package minijava.Typechecker;

import java.util.List;
import java.util.ArrayList;
import minijava.node.*;
import minijava.Type.*;

public class Phase2
{
    // TODO Print symbol table

    private Typechecker typechecker;

    Phase2(Typechecker typechecker) {
        this.typechecker = typechecker;
    }

    void process(Node n) {
    	 throw new RuntimeException(this.getClass() + ": no process method available for " 
	     + n.getClass());
    }

    ///////////////////////////////////////////////////////////////
    void process(Start n) {
         process(n.getPProgram());
    }

    ///////////////////////////////////////////////////////////////
    void process(PProgram n) {
        if (n instanceof AProgram) process((AProgram)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AProgram n) {
        n.getPublic();				// yields TPublic
        n.getClasstok();				// yields TClasstok
        n.getId();				// yields TId
        n.getLbrace();				// yields TLbrace
        for (PMaindecl p : n.getMaindecl())
            process(p);				// process(PMaindecl)
        n.getRbrace();				// yields TRbrace
    }

    ///////////////////////////////////////////////////////////////
    void process(PMaindecl n) {
        if (n instanceof AVarMaindecl) process((AVarMaindecl)n);
	else if (n instanceof AMethodMaindecl) process((AMethodMaindecl)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AVarMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi
        typechecker.globalST.put(n.getId().getText(), process(n.getType()));
    }

    ///////////////////////////////////////////////////////////////
    void process(AMethodMaindecl n) {
        process(n.getPrivacy());			// process(PPrivacy)
        n.getStatic();				// yields TStatic
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        process(n.getParamlist());			// process(PParamlist)
        n.getRparen();				// yields TRparen
        n.getLbrace();				// yields TLbrace
        typechecker.localST.increaseScope();
        for (PStmt p : n.getStmt())
            process(p);				// process(PStmt)
        n.getRbrace();				// yields TRbrace
        typechecker.localST.decreaseScope();
    }

    ///////////////////////////////////////////////////////////////
    void process(PParamlist n) {
        if (n instanceof AListParamlist) process((AListParamlist)n);
        else if (n instanceof AEmptyParamlist) process((AEmptyParamlist)n);
        else
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PParamlist)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AListParamlist n) {
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
        for (PParam p : n.getParam())
            process(p);				// process(PParam)
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptyParamlist n) {
    }

    ///////////////////////////////////////////////////////////////
    void process(PParam n) {
        if (n instanceof AParam) process((AParam)n);
	    else
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PParam)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AParam n) {
        n.getComma();				// yields TComma
        process(n.getType());			// process(PType)
        n.getId();				// yields TId
    }

    ///////////////////////////////////////////////////////////////
    void process(PPrivacy n) {
        if (n instanceof APublicPrivacy) process((APublicPrivacy)n);
	else if (n instanceof ABlankPrivacy) process((ABlankPrivacy)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrivacy)");
    }

    ///////////////////////////////////////////////////////////////
    void process(APublicPrivacy n) {
        n.getPublic();				// yields TPublic
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlankPrivacy n) {
    }

    ///////////////////////////////////////////////////////////////
    Type process(PType n) {
        if (n instanceof AType) return process((AType)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PType)");
    }

    ///////////////////////////////////////////////////////////////
    Type process(AType n) {
        Type type = typechecker.getType(n.getId());
        for (PEmptydim p : n.getEmptydim())
            type = typechecker.makeArrayType(type, n.getId());
        System.out.println("Type is "+type);
        return type;
    }

    ///////////////////////////////////////////////////////////////
    void process(PStmt n) {
        if (n instanceof AWhileStmt) process((AWhileStmt)n);
	else if (n instanceof ADeclStmt) process((ADeclStmt)n);
	else if (n instanceof ABlockStmt) process((ABlockStmt)n);
	else if (n instanceof AIfStmt) process((AIfStmt)n);
	else if (n instanceof AExprStmt) process((AExprStmt)n);
	else if (n instanceof AReturnStmt) process((AReturnStmt)n);
	else if (n instanceof APrintStmt) process((APrintStmt)n);
	else if (n instanceof AEmptyStmt) process((AEmptyStmt)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PStmt)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AWhileStmt n) {
        n.getWhile();				// yields TWhile
        n.getLparen();				// yields TLparen
        if (!process(n.getExpr()).getType().equals(Type.booleanType))			// process(PExpr)
        //@TODO Check to see if this error token is too ratchet
            throw new TypecheckerException(n.getLparen(), "Incompatible type");
        n.getRparen();				// yields TRparen
        process(n.getStmt());			// process(PStmt)
    }

    ///////////////////////////////////////////////////////////////
    void process(ADeclStmt n) {
        Type type = process(n.getType());			// process(PType)
        System.out.println(n.getId().getText());
        System.out.println(type);
        n.getId();				// yields TId
        n.getSemi();				// yields TSemi
        boolean declared = typechecker.localST.declareLocal(n.getId().getText(), type);
        if (!declared) {
            throw new TypecheckerException(n.getId(), "A variable of the same name has already been declared.");
        }
    }

    ///////////////////////////////////////////////////////////////
    void process(ABlockStmt n) {
        n.getLbrace();				// yields TLbrace
        typechecker.localST.increaseScope();
        for (PStmt p : n.getStmt())
            process(p);				// process(PStmt)
        n.getRbrace();				// yields TRbrace
        typechecker.localST.decreaseScope();
    }

    ///////////////////////////////////////////////////////////////
    void process(AIfStmt n) {
        n.getIf();				// yields TIf
        n.getLparen();				// yields TLparen
        if (!process(n.getExpr()).getType().equals(Type.booleanType))			// process(PExpr)
            //@TODO Check to see if this error token is too ratchet
            throw new TypecheckerException(n.getLparen(), "Incompatible type");
        n.getRparen();				// yields TRparen
        process(n.getThenclause());			// process(PStmt)
        n.getElse();				// yields TElse
        process(n.getElseclause());			// process(PStmt)
    }

    ///////////////////////////////////////////////////////////////
    void process(AExprStmt n) {
        process(n.getExpr());			// process(PExpr)
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    void process(AReturnStmt n) {
        // TODO return type, figure out how to check the return type against the expected return type
        n.getReturn();				// yields TReturn
        if (n.getExpr() != null)
            process(n.getExpr());		// process(PExpr)
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    void process(APrintStmt n) {
        n.getPrint();				// yields TPrint
        n.getLparen();				// yields TLparen
        if (process(n.getExpr()).getType().equals(Type.voidType)) {
            throw new TypecheckerException(n.getLparen(), "type not allowed here");
        }
        n.getRparen();				// yields TRparen
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptyStmt n) {
        n.getSemi();				// yields TSemi
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr n) {
        if (n instanceof AAssignExpr) return process((AAssignExpr)n);
	else if (n instanceof AExprExpr) return process((AExprExpr)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AAssignExpr n) {
        ExprType lhs = process(n.getLhs());			// process(PLhs)
        ExprType rhs = process(n.getExpr());			// process(PExpr)
        if (!(lhs.getType().equals(rhs.getType()))){
            throw new TypecheckerException(n.getAssign(), "Incompatible types.");
        }
        return lhs;
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr n) {
        return process(n.getExpr10());			// process(PExpr10)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr10 n) {
        if (n instanceof AOrExpr10) return process((AOrExpr10)n);
	else if (n instanceof AExprExpr10) return process((AExprExpr10)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr10)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AOrExpr10 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr10)
        n.getOr();				// yields TOr
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr20)
        if ((!typeLHS.equals(Type.booleanType)) || (!typeRHS.equals(Type.booleanType))){
            throw new TypecheckerException(n.getOr(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr10 n) {
        return process(n.getExpr20());			// process(PExpr20)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr20 n) {
        if (n instanceof AAndExpr20) return process((AAndExpr20)n);
	else if (n instanceof AExprExpr20) return process((AExprExpr20)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr20)");

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AAndExpr20 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr20)
        n.getAnd();				// yields TAnd
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr30)
        if ((!typeLHS.equals(Type.booleanType)) || (!typeRHS.equals(Type.booleanType))){
            throw new TypecheckerException(n.getAnd(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr20 n) {
        return process(n.getExpr30());			// process(PExpr30)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr30 n) {
        if (n instanceof AEqExpr30) return process((AEqExpr30)n);
	else if (n instanceof ANeExpr30) return process((ANeExpr30)n);
	else if (n instanceof AExprExpr30) return process((AExprExpr30)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr30)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AEqExpr30 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr30)
        n.getEq();				// yields TEq
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr40)
        if (!typeLHS.equals(typeRHS)){
            throw new TypecheckerException(n.getEq(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANeExpr30 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr30)
        n.getNe();				// yields TNe
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr40)
        if (!typeLHS.equals(typeRHS)){
            throw new TypecheckerException(n.getNe(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr30 n) {
        return process(n.getExpr40());			// process(PExpr40)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr40 n) {
        if (n instanceof ALtExpr40) return process((ALtExpr40)n);
	else if (n instanceof ALeExpr40) return process((ALeExpr40)n);
	else if (n instanceof AGeExpr40) return process((AGeExpr40)n);
	else if (n instanceof AGtExpr40) return process((AGtExpr40)n);
	else if (n instanceof AExprExpr40) return process((AExprExpr40)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr40)");

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALtExpr40 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr40)
        n.getLt();				// yields TLt
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr50)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType))){
            throw new TypecheckerException(n.getLt(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALeExpr40 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr40)
        n.getLe();				// yields TLe
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr50)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType))){
            throw new TypecheckerException(n.getLe(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AGeExpr40 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr40)
        n.getGe();				// yields TGe
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr50)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType))){
            throw new TypecheckerException(n.getGe(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AGtExpr40 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr40)
        n.getGt();				// yields TGt
        Type typeRHS = process(n.getRight()).getType();			// process(PExpr50)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType))){
            throw new TypecheckerException(n.getGt(), "Incompatible types");
        }
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AExprExpr40 n) {
        return process(n.getExpr50());			// process(PExpr50)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PExpr50 n) {
        if (n instanceof APlusExpr50) return process((APlusExpr50)n);
	else if (n instanceof AMinusExpr50) return process((AMinusExpr50)n);
	else if (n instanceof ATermExpr50) return process((ATermExpr50)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PExpr50)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APlusExpr50 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr50)
        n.getPlus();				// yields TPlus
        Type typeRHS = process(n.getRight()).getType();			// process(PTerm)
        if (!(((typeLHS.equals(Type.intType)) && (typeRHS.equals(Type.intType)))
             || ((typeLHS.equals(Type.stringType)) && (typeRHS.equals(Type.stringType)))))
            {
            throw new TypecheckerException(n.getPlus(), "Incompatible types");
        }
        return new ExprType(null, typeLHS);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AMinusExpr50 n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PExpr50)
        n.getMinus();				// yields TMinus
        Type typeRHS = process(n.getRight()).getType();			// process(PTerm)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType)))
        {
            throw new TypecheckerException(n.getMinus(), "Incompatible types");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATermExpr50 n) {
        return process(n.getTerm());			// process(PTerm)

    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PTerm n) {
        if (n instanceof ATimesTerm) return process((ATimesTerm)n);
	else if (n instanceof ADivTerm) return process((ADivTerm)n);
	else if (n instanceof AModTerm) return process((AModTerm)n);
	else if (n instanceof AFactorTerm) return process((AFactorTerm)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PTerm)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATimesTerm n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PTerm)
        n.getTimes();				// yields TTimes
        Type typeRHS = process(n.getRight()).getType();			// process(PFactor)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType)))
        {
            throw new TypecheckerException(n.getTimes(), "Incompatible types");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ADivTerm n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PTerm)
        n.getDiv();				// yields TDiv
        Type typeRHS = process(n.getRight()).getType();			// process(PFactor)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType)))
        {
            throw new TypecheckerException(n.getDiv(), "Incompatible types");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AModTerm n) {
        Type typeLHS = process(n.getLeft()).getType();			// process(PTerm)
        n.getMod();				// yields TMod
        Type typeRHS = process(n.getRight()).getType();			// process(PFactor)
        if ((!typeLHS.equals(Type.intType)) || (!typeRHS.equals(Type.intType)))
        {
            throw new TypecheckerException(n.getMod(), "Incompatible types");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFactorTerm n) {
        return process(n.getFactor());			// process(PFactor)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PFactor n) {
        if (n instanceof APrimaryFactor) return process((APrimaryFactor)n);
	else if (n instanceof AIdFactor) return process((AIdFactor)n);
	else if (n instanceof ALengthFactor) return process((ALengthFactor)n);
	else if (n instanceof ALength2Factor) return process((ALength2Factor)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PFactor)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryFactor n) {
        return process(n.getPrimary());			// process(PPrimary)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdFactor n) {
        n.getId();				// yields TId
        Type type = typechecker.localST.lookup(n.getId().getText());
        if (type==null){
            type = typechecker.globalST.get(n.getId().getText());
            if (type==null){
                throw new TypecheckerException(n.getId(), "Variable not declared");
            }
        }
        return new ExprType(null, type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALengthFactor n) {
        n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        if (!(typechecker.localST.lookup(n.getId().getText()) instanceof ArrayType)) {
            throw new TypecheckerException(n.getId(), "Is not an array");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ALength2Factor n) {
        n.getId();				// yields TId
        n.getDot();				// yields TDot
        n.getLength();				// yields TLength
        n.getLparen();				// yields TLparen
        n.getRparen();				// yields TRparen
        // TODO why .length()? instead of .size()
        if (!((typechecker.localST.lookup(n.getId().getText())) instanceof ArrayType)) {
            throw new TypecheckerException(n.getId(), "Is not an array");
        }
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary n) {
        if (n instanceof ANewarrayPrimary) return process((ANewarrayPrimary)n);
	else if (n instanceof APrimary2Primary) return process((APrimary2Primary)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrimary)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANewarrayPrimary n) {
        n.getNew();				// yields TNew
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType withinBrackets = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        for (PEmptydim p : n.getEmptydim())
            process(p);				// process(PEmptydim)
        if (!withinBrackets.getType().equals(Type.intType)) {
            throw new TypecheckerException(n.getId(), "No number in brackets");
        }
        if (!typechecker.checkVarType(n.getId())) {
            throw new TypecheckerException(n.getId(), "Invalid type");
        }
        return new ExprType(null, typechecker.getType(n.getId()));
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimary2Primary n) {
        return process(n.getPrimary2());			// process(PPrimary2)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PPrimary2 n) {
        if (n instanceof AIconstPrimary2) return process((AIconstPrimary2)n);
	else if (n instanceof ASconstPrimary2) return process((ASconstPrimary2)n);
	else if (n instanceof ANullPrimary2) return process((ANullPrimary2)n);
	else if (n instanceof ATruePrimary2) return process((ATruePrimary2)n);
	else if (n instanceof AFalsePrimary2) return process((AFalsePrimary2)n);
	else if (n instanceof AParensPrimary2) return process((AParensPrimary2)n);
	else if (n instanceof ACallPrimary2) return process((ACallPrimary2)n);
	else if (n instanceof AArrayrefPrimary2) return process((AArrayrefPrimary2)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PPrimary2)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIconstPrimary2 n) {
        n.getIconst();				// yields TIconst
        return new ExprType(null, Type.intType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ASconstPrimary2 n) {
        n.getSconst();				// yields TSconst
        return new ExprType(null, Type.stringType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANullPrimary2 n) {
        n.getNull();				// yields TNull
        return new ExprType(null, Type.nullType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ATruePrimary2 n) {
        n.getTrue();				// yields TTrue
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AFalsePrimary2 n) {
        n.getFalse();				// yields TFalse
        return new ExprType(null, Type.booleanType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AParensPrimary2 n) {
        n.getLparen();				// yields TLparen
        return process(n.getExpr());			// process(PExpr)
//        n.getRparen();				// yields TRparen
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ACallPrimary2 n) {
        n.getId();				// yields TId
        n.getLparen();				// yields TLparen
        List<ExprType> exprTypeList = new ArrayList<>();
        if (n.getArglist() != null)
            exprTypeList = process(n.getArglist());		// process(PArglist)
        n.getRparen();				// yields TRparen
        List<Type> typeList = new ArrayList<>();
        for (ExprType exprType : exprTypeList){
            typeList.add(exprType.getType());
        }
        List<Method> methodList = typechecker.findMethods(n.getId().getText(), typeList);
        if (methodList.size() > 1) {
            throw new TypecheckerException(n.getId(), "Ambiguous method");
        } else if (methodList.isEmpty()) {
            throw new TypecheckerException(n.getId(), "Method not declared");
        }
        return new ExprType(null, methodList.get(0).getReturnType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefPrimary2 n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArrayref n) {
        if (n instanceof ANameArrayref) return process((ANameArrayref)n);
	else if (n instanceof APrimaryArrayref) return process((APrimaryArrayref)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArrayref)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(ANameArrayref n) {
        n.getId();				// yields TId
        n.getLbrack();				// yields TLbrack
        ExprType withinBrackets = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        if (!withinBrackets.getType().equals(Type.intType)) {
            throw new TypecheckerException(n.getId(), "Not a number within the brackets");
        }
        Type type = typechecker.localST.lookup(n.getId().getText());
        if (type == null || (!(type instanceof ArrayType))) {
            type = typechecker.globalST.get(n.getId().getText());
            if (type == null || (!(type instanceof ArrayType))) {
                throw new TypecheckerException(n.getLbrack(), "Error 404 Variable not found");
            }
        }
        return new ExprType(null, type);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(APrimaryArrayref n) {
        ExprType arrayType = process(n.getPrimary2());			// process(PPrimary2)
        n.getLbrack();				// yields TLbrack
        ExprType inner = process(n.getExpr());			// process(PExpr)
        n.getRbrack();				// yields TRbrack
        //i dont think we need to check here
//        if (!(typechecker.localST.lookup(n.getId().getText()) instanceof ArrayType)) {
//            throw new TypecheckerException(n.getId(), "Is not an array");
//        }
        if (inner.getType() != Type.intType) {
            throw new TypecheckerException(n.getLbrack(), "Incompatible type.");
        }

        return new ExprType(null, arrayType.getType());
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PLhs n) {
        if (n instanceof AIdLhs) return process((AIdLhs)n);
	else if (n instanceof AArrayrefLhs) return process((AArrayrefLhs)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PLhs)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AIdLhs n) {
        n.getId();				// yields TId
        Type lhsType = typechecker.localST.lookup(n.getId().getText());
        if (lhsType == null) {
            throw new TypecheckerException(n.getId(), "Cannot find symbol.");
        }
        return new ExprType(null, lhsType);
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArrayrefLhs n) {
        return process(n.getArrayref());			// process(PArrayref)
    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(PArglist n) {
        if (n instanceof AListArglist) return process((AListArglist)n);
	    else
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PArglist)");
    }

    ///////////////////////////////////////////////////////////////
    List<ExprType> process(AListArglist n) {
        List<ExprType> typeList = new ArrayList<>();
        typeList.add(process(n.getExpr()));			// process(PExpr)
        for (PArg p : n.getArg())
            typeList.add(process(p));				// process(PArg)
        return typeList;
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(PArg n) {
        if (n instanceof AArg) return process((AArg)n);
	    else
            throw new RuntimeException (this.getClass() +
                ": unexpected subclass " + n.getClass() + " in process(PArg)");
    }

    ///////////////////////////////////////////////////////////////
    ExprType process(AArg n) {
        n.getComma();				// yields TComma
        return process(n.getExpr());			// process(PExpr)
    }
    // ignore this one
    ///////////////////////////////////////////////////////////////
    void process(PEmptydim n) {
        if (n instanceof AEmptydim) process((AEmptydim)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PEmptydim)");

        throw new UnsupportedOperationException ();     // remove when method is complete
    }
    // ignore this one
    ///////////////////////////////////////////////////////////////
    void process(AEmptydim n) {
        n.getLbrack();				// yields TLbrack
        n.getRbrack();				// yields TRbrack

        throw new UnsupportedOperationException ();     // remove when method is complete
    }

}
