/* This file was generated by the Amherst version of SableCC */

package minijava.Typechecker;

import minijava.node.*;
import minijava.Type.*;

import java.util.List;
import java.util.ArrayList;

/*TODO:
- check if multiple variable declaration
- reusing variable name
- no void types for variable declaration
- no null types in general
- no void types in paramList
- use actual proper types (typeMap check)
- check proper return types
*/

public class Phase1
{
    private Typechecker typechecker;
    Phase1(Typechecker typechecker) {
        this.typechecker = typechecker;
    }

    void process(Node n) {
    	 throw new RuntimeException(this.getClass() + ": no process method available for " 
	     + n.getClass());
    }

    ///////////////////////////////////////////////////////////////
    void process(Start n) {
         process(n.getPProgram());
    }

    ///////////////////////////////////////////////////////////////
    void process(PProgram n) {
        process((AProgram)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AProgram n) {
        n.getId();				// yields TId
	for (PMaindecl p : n.getMaindecl())
	    process(p);				// process(PMaindecl)
    }

    ///////////////////////////////////////////////////////////////
    void process(PMaindecl n) {
        if (n instanceof AVarMaindecl) process((AVarMaindecl)n);
	    else process((AMethodMaindecl)n);
    }

    ///////////////////////////////////////////////////////////////
    void process(AVarMaindecl n) {
        TId typeId = ((AType)n.getType()).getId();
        if (!typechecker.checkVarType(typeId)){
            throw new TypecheckerException(typeId, "Variable cannot be declared with given type.");
        }
        if (!typechecker.checkIfVarDeclared(n.getId())){
            throw new TypecheckerException(n.getId(), "Variable has already been declared.");
        }
        typechecker.createClassVar(n.getId().getText(), process(n.getType()), n.getId());
    }

    ///////////////////////////////////////////////////////////////
    void process(AMethodMaindecl n) {
        TId typeId = ((AType)n.getType()).getId();
        if (!typechecker.checkMethodType(typeId)){
            throw new TypecheckerException(typeId, "Method cannot be declared with given type.");
        }
        //@TODO Take process out and make sure it only happens once
        if (!typechecker.checkIfMethodDeclared(n.getId().getText(), process(n.getType()), process(n.getParamlist()), n.getId())){
            throw new TypecheckerException(n.getId(), "Method has already been declared.");
        }
        typechecker.createMethod(n.getId().getText(), process(n.getType()), process(n.getParamlist()), n.getId());
    }

    ///////////////////////////////////////////////////////////////
    List<Type> process(PParamlist n) {
        if (n instanceof AListParamlist) return process((AListParamlist)n);
	    else return process((AEmptyParamlist)n);
    }

    ///////////////////////////////////////////////////////////////
    List<Type> process(AListParamlist n) {
        List<Type> typeList = new ArrayList<>();
        TId typeId = ((AType)n.getType()).getId();
        if (!typechecker.checkVarType(typeId)){
            throw new TypecheckerException(typeId, "Parameter cannot be declared with given type.");
        }
        typeList.add(process(n.getType()));			// process(PType)
	    for (PParam p : n.getParam()) {
            typeId = (((AType) ((AParam) p).getType())).getId();
            if (!typechecker.checkVarType(typeId)) {
                throw new TypecheckerException(typeId, "Parameter cannot be declared with given type.");
            }
            typeList.add(process(p));                // process(PParam)
        }
        return typeList;
    }

    ///////////////////////////////////////////////////////////////
    List<Type> process(AEmptyParamlist n) {
        List<Type> typeList = new ArrayList<>();
        return typeList;
    }

    ///////////////////////////////////////////////////////////////
    Type process(PParam n) {
        return process((AParam)n);
    }

    ///////////////////////////////////////////////////////////////
    Type process(AParam n) {
        return process(n.getType());			// process(PType)
    }

    ///////////////////////////////////////////////////////////////
    Type process(PType n) {
        return process((AType)n);
    }

    ///////////////////////////////////////////////////////////////
    Type process(AType n) {
        Type type = typechecker.getType(n.getId());
//        if (!n.getEmptydim().isEmpty()){
//            if (!typechecker.checkVarType(n.getId())){
//                throw new TypecheckerException(n.getId(), "Invalid array basetype.");
//            }
//        }
        for (PEmptydim p : n.getEmptydim())
            type = typechecker.makeArrayType(type, n.getId());
        return type;
    }

    ///////////////////////////////////////////////////////////////
    void process(PEmptydim n) {
        if (n instanceof AEmptydim) process((AEmptydim)n);
	else 
            throw new RuntimeException (this.getClass() + 
                ": unexpected subclass " + n.getClass() + " in process(PEmptydim)");
    }

    ///////////////////////////////////////////////////////////////
    void process(AEmptydim n) {
        n.getLbrack();				// yields TLbrack
        n.getRbrack();				// yields TRbrack
    }

}
